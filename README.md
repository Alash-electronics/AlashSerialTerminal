# Библиотека терминала посредством последовательного порта для Arduino
Библиотека была создана для образовательных целей компанией Alash education.

Это универсальная библиотека терминала посредством последовательного порта для Arduino, предназначенная для разбора ASCII-команд и аргументов.

![Снимок экрана 2024-06-09 185842](https://github.com/Alash-electronics/AlashSerialTerminal/assets/171731850/15fae77c-308b-484e-bcaa-c4d08d2a475a)


## Аппаратное обеспечение

Любое аппаратное обеспечение Arduino с последовательным портом, такое как:

Arduino:
* UNO
* Nano
* Micro
* Pro или Pro Mini
* Mega или Mega2560
* Leonardo

Другие платформы:
* DUE
* ESP8266
* ESP32
* SAMD21
* STM32F1

Рекомендуем так же скачать библиотеку Alash Serial Terminal для работы с Терминалом https://github.com/Alash-electronics/AlashSerialTerminal
## Использование

**Инициализация**

Создайте объект терминала посредством последовательного порта. Его можно инициализировать с необязательными символами новой строки и разделителями.

Символ новой строки по умолчанию: ```'\n'```
Символ разделителя по умолчанию: ```Пробел```

```c++
#include <AlashSerialTerminal.h>

// Символ новой строки '\r' или '\n'
char newlineChar = '\n'; 
// Символ-разделитель между командами и аргументами
char delimiterChar = ' ';

// Создание объекта терминала посредством последовательного порта
SerialTerminal term(newlineChar, delimiterChar);


void setup()
{
    // Инициализация последовательного порта
    Serial.begin(115200);
    
    // Инициализация встроенного светодиода
    pinMode(LED_BUILTIN, OUTPUT);
    digitalWrite(LED_BUILTIN, LOW);
}
```
**Регистрация новых команд**

Команды должны быть зарегистрированы при запуске с соответствующим ```обработчиком обратного вызова```. Это регистрирует только команду, исключая аргументы.

Обработчик обратного вызова будет вызван, когда команда будет получена, включая символ новой строки.

Пример регистрации нескольких команд:

```c++
void setup()
{
    ...

    // Добавление обработчиков обратного вызова команд
    term.addCommand("?", cmdHelp);
    term.addCommand("help", cmdHelp);
    term.addCommand("on", cmdLedOn);
    term.addCommand("off", cmdLedOff);
}

void cmdHelp()
{
    // Вывод использования
    Serial.println(F("Использование серийного терминала:"));
    Serial.println(F("  help или ?          Вывести это использование"));
    Serial.println(F("  on                  Включить светодиод"));
    Serial.println(F("  off                 Выключить светодиод"));
}

void cmdLedOn()
{
    // Включение светодиода
    Serial.println(F("Светодиод включен"));
    digitalWrite(LED_BUILTIN, HIGH);
}

void cmdLedOff()
{
    // Выключение светодиода
    Serial.println(F("Светодиод выключен"));
    digitalWrite(LED_BUILTIN, LOW);
}
```

**Установка обработчика по умолчанию**

Необязательно: Обработчик по умолчанию будет вызван, когда команда не распознана.

```c++
void setup()
{   
    ...

    // Установка обработчика по умолчанию для неизвестных команд
    term.setDefaultHandler(unknownCommand);
}

void unknownCommand(const char *command)
{
    // Вывод неизвестной команды
    Serial.print(F("Неизвестная команда: "));
    Serial.println(command);
}
```

**Чтение из последовательного порта**

Чтение из последовательного порта в основном цикле:

```c++
void loop()
{
    // Чтение из последовательного порта и обработка обратных вызовов команд
    term.readSerial();
}
```

**Получение следующего аргумента**

Получение указателя на следующий аргумент в буфере приема последовательного порта:

```c++
char *arg;

// Получение следующего аргумента
arg = term.getNext();
if (arg != NULL) {
    Serial.print(F("Аргумент: "));
    Serial.println(arg);
} else {
    Serial.println(F("Нет аргумента"));
}
```

**Получение оставшихся символов**

Получение указателя на оставшиеся символы в буфере приема последовательного порта:

```c++
char *arg;

// Получение оставшихся символов
arg = term.getRemaining();
if (arg != NULL) {
    Serial.print(F("Оставшиеся: "));
    Serial.println(arg);
}
```

**Очистка буфера**

Необязательно: Буфер приема последовательного порта можно очистить следующим вызовом:

```c++
term.clearBuffer();
```


**Включение/отключение эха символов**

Необязательно: Разрешение вывода любых введенных символов обратно в интерфейс последовательного порта.
Это полезно для терминальных программ, таких как PuTTY.
Поддерживает оба символа "Backspace", ^H и ^127.

```c++
term.setSerialEcho(true); // Включение эха символов
```


**Установка обработчика после команды**

Необязательно: Добавление функции, которая будет вызвана ПОСЛЕ обработки команды.

```c++
void setup()
{   
    ...

    // Установка обработчика, который будет запущен ПОСЛЕ обработки команды.
    term.setPostCommandHandler(postCommandHandler);
}

void setPostCommandHandler()
{
    // Вывод '> ' для простого пользовательского интерфейса
    Serial.print(F("> "));
}
```

## Конфигурация библиотеки

```SerialTerminal.h``` содержит следующие макросы конфигурации:

* ```ST_RX_BUFFER_SIZE``` : Размер буфера приема по умолчанию для последовательного порта составляет 32 байта. Это включает в себя команду и аргументы, за исключением символа ```'\0'```.
* ```ST_NUM_COMMAND_CHARS```: Количество символов команды по умолчанию составляет 8 байт, за исключением символа ```'\0'```.
